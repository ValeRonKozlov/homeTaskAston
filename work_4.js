/*  1. Какие бывают алгоритмы сортировок? 
  !!! Вопрос: Что такое алгоритм? Это набор инструкций описывающий порядок действий для достижения определённых целей и решения конкретных задач.

	!! Вопрос: Что такое Big O notation? Это нотация, которая позволяет определить верхнюю границу скорости работы алгаритма.

	Алгоритмы сортировок:
	!- Сортировка пузырьком(
		Самый примитивный и базовый алгоритм сортировки.Он является основой для других алгоритмов сортировки.Этот алгоритм является стабильным.
			Сортировка состоит в переборе массива и сравнения соседних элементов друг с другом и меняя их местами в соответствии с условиями. Элементы с большим значеникм 
			опускаются вниз, а элементы с меньшим значением поднимаютя наверх. Сложность алгоритма O(N^2)- где n колличество элементов массива.Так как мы запускаем вложенный
			цикл то сложность будет n^2.
			Шаги реализации:
				- Запускаем цикл i по массиву
				- Запускаем внутренний цикл j, который идет от 0 до arr.length - i. Это что бы цикл не проходил по уже отсортированным элементам
				- Во внутреннем цикле проверяем соседние элементы и меняем их местами, если сосед слева больше соседа справа 

				const bubleSort = (arr) => {
					for (let i = 0; i < arr.length; i++) {
						for (let j = 0; j < arr.length - i; j++) {
							if(arr[j] > arr[j + 1]) {
								[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] //меняем элементы местами
							}
						}
					}
				} 

				Этот алгоритм лучше использовать когда колличество входных данных невелико, так как его временная сложность составляет O(n^2)
		)
	!- Сортировка выбором(
		Этот алгоритм сортировки при каждой итерации проходит по неотсортированной части массива, находит минимальный элемент и переносит его в начало массива.
		Он может быть как стабильным так и нестабильным в зависимости от реализации
		Сложность алгоритма O(n^2)
		Шаги реализации:
			- Запускаем цикл i по массиву
			- Внутри цикла создаем переменную, равную итерации цикла min = i
			- Запускаем внутренний цикл j по оставшимся элементам до конца массива
			- Если элемент arr[i] > arr[j], то присваиваем min значение j
			- По окончанию внутреннего цикла j переменная min хранит индекс наименьшего неотсортированного элемента массива
			- Меняем местами элементы  с индексами min и i 

			const selectedSort = (arr) => {
				for (let i = 0; i < arr.length; i++) {
					let min = i;
					for (let j = i + 1; j < arr.length; j++) {
						if (arr[i] > arr[j]) {
							min = j;
						}
					}
					[arr[i], arr[min]] = [arr[min], arr[i]]
				}
			}

			Этот алгоритм лучше использовать когда колличество входных данных невелико, так как его временная сложность составляет O(n^2)
	)
	!- Циклическая сортировка(
		Шаги реализации:
			- Запускаем цикл i, который должен пройти по всему массиву
			- Создаём прерменную position которая будет равна i
			- Запускаем внутренний цикл j, который перебирает всех соседей справа
			- Когда внутренний цикл находит элемент который меньше arr[i], увеличиваем position на 1
			- Если значение position = i, переходим к следующей итерации внешнего цикла i
			- Пропускаем дубликаты, сравнивая значения элементов под индексами position и i с помощью цикла
			- Меняем местами элементы под индексами position и i
			- Запускаем цикл, пока position не будет ссылаться на i
			- Повторяем все операции, описсанные внутри цикла j

			function cycleSort(arr) {
				for (let i = 0; i < arr.length; i++) {
					let position = i;
					let value = arr[i];

					for (let j = i + 1; j < arr.length; j++) {
						if (arr[j] < value) {
							position++;
						}
					}
					if (position == i) {
						continue;
					}

					while (value === arr[position]) {
						position++; // избавляемся от дубликатов
					}

					[arr[position], value] = [value, arr[position]]; // меняем значения переменных

					while (position !== i) { // запускаем цикл в обратную сторону
						position = i;

						for (let k = i + 1; k < arr.length; k++) {
							if (arr[k] < value) {
								position++;
							}
						}
						while (value === arr[position]) {
							position++; // избавляемся от дубликатов
						}
						[arr[position], value] = [value, arr[position]] // меняем значения переменных
					}
				}
				return arr;
			}

			Алгоритм следует использовать Когда запись в сортируемый набор данных очень дорога
	)

	!- Быстрая сортирока(
		Алгоритм быстрой сортировки работает следующим образом: он определяет так называемый стержень и
		разбивает массив на подмассивы относительно стержня которые затем сортируются

		Этот алгоритм является нестабильным
		сложность алгоритма в среднем O(n * log n). В худшем случае O(n^2) Худшим можно назвать случай когда опорный элемент имеет максимальное или минимальное значение во всём массиве

		Шаги реализации:
			- проверяем что указатель начала массива не совпадает с указателем на конец массива
			- Если условие выполняется, находим индекс элемента, который разделяет массив на 2 части pi
			- Когда pi найден, рекурсивно запускаем quickSort для каждой из получившихся частей(от старта до pi - 1) и (от pi + 1 до конца)
			- При нахождении pi мы определяем опорный элемент и индекс по которому будем делить массив
			- Запускаем цикл по массиву до предпоследнего элемента. При нахождении элемента который меньше или равен опорному элементу меняем местами элементы arr[i] and arr[j] и инкременируем индекс
			- После завершения цикла меняем местами arr[i] arr[end] и возвращаем i

			const partition = (arr, start, end) => {
				const  pivot = arr[end]; // Определяем опорный элемент
				let i = start;  // Определяем индекс по которому делим массив на две части

				for (let j = start; j <= end - 1; j++) {
					if (arr[i] <= pivot) {
						[arr[i], arr[j]] = [arr[j], arr[i]] //Меняем значения переменных
						i++
					}
				}
				[arr[i], arr[end]] = [arr[end], arr[i]] // Меняем значения переменных
				return i;
			}

			const quickSort = (arr, start, end) => {
				if (start < end) { // условия запуска рекурсии
					const pi = partition(arr, start, end) // Получаем индекс

					quickSort(arr, start, pi - 1);
					quickSort(arr, pi + 1, end);
				}
			}

			Такой алгоритм используют при обработке большого обьема входных данных и когда требуется использовать наиболее быстрый алгоритм
	)

	!!Вопрос: Подразделения Алгоритмов сортировки? Алгоритмы сортировки подразделяются на стабильные и нестабильные.
	Алгоритм является стабильным только в том случае, если он не меняет порядок элементов с одинаковыми значениями относительно друг друга. Соответственно
	нестабильный алгоритм - наоборот.


	! Алгоритмы Поиска:
		- Линейный поиск
		- Бинарный поиск 
		- Поиск в ширину и глубину
		- Алгоритм Дейкстры
*/ 

/* 2 Прочитать про "Операторы и выражения, циклы в JS"
		!! Вопрос: Какие есть операторы в JS?
			- Операторы Присвоения (=)
			- Операторы Сравнения (< > <= >= == )
			- Арифмитические операторы (+ - * /  и тд)
			- Битовые(поразрядные) операторы (& | ^ ~ << >> >>> сдвиг в право с заполнением нулями)
			- Логические операторы (&& || ! )
			- Строковые операторы (+ соединение 2 строк += )
			- Условный(тернарный) оператор
			- Оператор запятая (вычесляет два операнда и возвращает значение последнего в основном 			используется внутри цикла For)
			- Унарные операторы (i++ || ++i)
			- Операторы отношения (in )
			-	Оператор Delete (выполняет удаление обьекта, свойства обьекта, элемента массива по индексу)
			- Оператор typeof (возвращает строку обозначающую тип невычесленного операнда)
			- Оператор Void определяет выражение которое должно быть вычеслено без возвращения результата
			- Оператор instanceof возвращает true если заданный обьект является обьектом заданного типа 

			!Вопрос Какой оператор использует 3 операнда? Тернарный оператор условие ? значние1 : значение2

			!Деструктуризация - это выражение которое позволяет извлекать данные из массивов или обьектов, используя синтаксис, который зеркалирует конструкторы массивов и литералы обьектов

			var foo = ["one", "two", "three"];
				без деструктуризации
				var one = foo[0];
				var two = foo[1];
				var three = foo[2];

				с деструктуризацией
				var [one, two, three] = foo;

			!Вопрос: Что такое Выражение? Выражением является любой корректный блок кода который возвращает значение.

			Есть 2 типа выражений:
				Которые присваивают значение переменной
				Которые вычисляют значения без присвоения

			!Категории Выражений:
				- Арифмитические
				- Строковые
				- Логические
				- Основные выражения (Используют оператор this для указания на текущий объект)
				- Левосторонние(значением слева назначаются значения справа)  (operator new) 

				Оператор группировки () Скобки контроллирует приоритет вычислений в выражениях
				Оператор расширения ... 

				!Вопрос: Что такое Цикл? Простой способ сделать какое то действие несколько раз.

				!Вопрос: Какие есть операторы для организации циклов в JS?
					- For
					- do while
					- while
					- label
					- break
					- continue
					- for in (проходит по всем перечислимым свойствам обьекта)
					- for of
*/

/* 3 Создать объект Person несколькими способами, после создать объект Person2, чтобы в нём были доступны методы объекта Person. Добавить метод logInfo чтоб он был доступен всем объектам.
	Конструктор функции

	function Person(name, age) {
	this.name = name;
	this.age = age;

	Использование Класса

	class Person {
		constructor(name, age) {
			this.name = name;
			this.age = age;
		}
	}

	Литерал обьекта
	const Person = {
		name: "Valeron",
		age: 42
	}
		
	Создание Person2:
		Наследование с помощью Object.create()
		const Person2 = Object.crate(Person.prototype)
		Person2.name = "Ron";
		Person2.age = 24;

		Наследование с помощью класса:
		class Person2 extends Person {
			constructor(name, age) {
				super(name, age)
			} 
		}

		Добавление метода
		Person.prototype.logInfo = function() {
			console.log(`Имя: ${this.name}, Возраст: ${this.age}.`)
		}
};
*/
//-------------------------------------------------------------------------------------------
const Person3 = {
	name: "Jonatan",
	age: 41
}

const Person4 = Object.create(Person3);
Person4.name = "Jon";
Person4.age = 21;

Person3.logInfo = function () {
	console.log(`Hello ${this.name}, Your age is: ${this.age}`);
};

Person3.logInfo();
Person4.logInfo();
//-------------------------------------------------------------------------------------------
class Person {
	constructor(name) {
		this.name = name
	}
	logInfo() {
		console.log(`Name: ${this.name}`);
	}
}

class Person2 extends Person {
	constructor(name) {
		super(name)
	}
}

console.log(new Person("Valeron"));
console.log(new Person2("Ron"));

new Person("Valeron").logInfo()
new Person2("Ron").logInfo()

class PersonThree extends Person {
	constructor(name, age) {
		super(name),
		this.age = age
	}
	get getInfo() {
		console.log(`PersonThree Name: ${this.name}, PersonThree Age: ${this.age}`);
		// return `PersonThree Name: ${this.name}`;
	}
	set setName(value) {
		this.name = value
	}
	set setAge(value) {
		this.age = value
	}
	greetings() {
		console.log(`Hello my dear friend! ${this.name}! Glad to see you!`);
	}
}

let user = new PersonThree();
user.setName = "Jonny";
user.setAge = 42;
user.greetings();
user.getInfo
user.logInfo();

user.setName = 2321232;
user.setAge = 'двадцать восемь тысяч лет';
user.greetings();
user.getInfo
user.logInfo()


/*БОНУС: 
		1 Написать функцию, которая вернет массив с первой парой чисел, сумма которых равна total:


		2 Какая сложность у вашего алгоритма ?

*/

arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
total = 13;
//result = [4, 9]

const firstSum = (arr, total) => {
	let result = [];
		for (let i = 0; i < arr.length; i++) {
			for (let j = 0; j < arr.length; j++) {
				if (arr[i] + arr[j] == total) {
					result = [arr[j], arr[i]]
				}
			}
		}
	return result; // Сложность O(n^2) так как цикл в цикле
}

const sumNumbers = (arr, total) => {
	let obj = {}
	for (let i = 0; i < arr.length; i++) {
		obj[arr[i]] = i;
	} 
	for (let i = 0; i < arr.length; i++) {
		let diff = total - arr[i];
		if (obj[diff]) {
			return [arr[i], arr[obj[diff]]]
		}
	}
	return [];
} // Сложность O(n) n - длинна массива


const sumOfTWo = (arr, total) => {
	let result = [];
	let firstIndex = 0;
	let lastIndex = arr.length - 1;
	let isDone = false;

	while (!isDone) {
		if (arr[firstIndex] + arr[lastIndex] === total) {
			result.push(arr[firstIndex]);
			result.push(arr[lastIndex]);
			isDone = true;
		}
		if (arr[firstIndex] + arr[lastIndex] > total) {
			lastIndex--;
		}
		if (arr[firstIndex] + arr[lastIndex] < total) {
			firstIndex++;
		}
		if (firstIndex === lastIndex) {
			isDone = true;
		}
	}
	return result;
} // Сложность O(n) n - длина массива

console.log(firstSum(arr,total))
console.log(sumNumbers(arr,total))
console.log(sumOfTWo(arr,total))

/* 
		!Вопрос: Что такое ООП ? Это парадигма программирования, которая строится на базе понятий класса иобьекта.

	Класс - это шаблон или схема на основе которой будет создаваться новый обьект
	Объекты - это конкретные экземпляры класса.Тоесть сущности созданные по заданному шаблону. Каждая такая сущность будет иметьчеткий набор характеристик(поля класса) и действий(методы класса).При этом каждый обьект также будет именть своё собственное внутреннее состояние к которому можно получить доступ ччерез this.
	
		!Вопрос: Сколько базовых принципов имеет ООП? Как называются?
		1 Наследование (Это цепочка прототипов в JS)
		2 Инкапсуляция (Инкапсуляция включает в себя идею о том, что данные объекта не должны быть напрямую доступны. Нужно вызывать методы вместо прямого доступа к данным. Инкапсуляция позволяет нам скрывать/показывать свойства функций.)
		3 Полиморфизм (заключается в способности вызывать один и тот же метод для разных объектов, и при этом каждый объект будет реагировать по-своему)
		4 Абстракция (в JS нет абстрактных классов, Можно создать что-то похожее на абстрактный класс, но на уровне языка данной функциональности не существует.)


		!Вопрос: Типы использования Полиморфизма?
		1 Полиморфизм во время компиляции (Перегрузка функции - это тип полиморфизма во время компиляции.Этот тип создает более одной функции с одинаковым именем и разными параметрами или типами. Но перезрузка функции не поддерживается в js, потому что при создании функции с одинаковыми именами JS переопределит последнюю функцию)

		2 Полиморфизм во время выполнения (Переопределние методов - это тип полиморфизма во время выполнения. Например используется для переопределения методов родительского класса в дочернем классе)

		!ВОПРОС: Типы доступа к свойствам класса? Существует четыре типа доступа к свойствам класса: TypeScript

		- public (Если к свойствам и функциям классов не применяется модификатор, то такие свойства и 	функции расцениваются как определенные модификатором public. В таком случае свойство/метод будут 	доступны при обращении извне данного класса.)
		- private (Если же к свойствам и методам применяется модификатор private, то к ним нельзя будет обратиться извне при создании объекта данного класса.)
		- protected (Модификатор protected действует аналогично private, за исключением того, что члены, объявленные protected, могут быть доступны в подклассах.)
		- readonly (Мы можем делать свойства, доступными только для чтения, с помощью ключевого слова readonly. Такие свойства должны быть инициализированы при их объявлении или в конструкторе.)

		!Вопрос: Что такое SOLID и как расшифровывается?
		Solid - это аббривиатура, скрывающая в себе набор из пяти базовых принципов разработки приложений с приминением ООП.Знание и понимание этих принципов помогает разработчикам найти общий язык в решении споров по качеству построения архитектуры

		S Single responsibility principle - принцип единственной ответственности(каждый класс или сущность должна выполнять только одну задачу)

		O	Open/Close principle - принцип открытости/закрытости (Все програмные сущности (классы, функции, модули) должны быть открыты для расширения, но закрыты для модификации)

		L Liskov substitution principle - принцип постановки Барбары Лисков (Создавать подклассы так что бы они могли заменить своих родителей(наследующий класс должен дополнять а не изменять базовый))

		I Interface segregation principle - принцип разделения интерфейсов (Много интерфейсов, специально предназанченных для клиентов, лучше чем один интерфейс общего назначения. Клиентские интерфейсы не должны зависить от интерфейсов которые они не используют)

		D Dependency inversion principle- принцип инверсии зависимостей (модули верхних уровней не должны зависеть от модулей нижних уровней, Оба типа модулей должны зависеть от абстракций, Абстракции не должны зависеть от детаалей, Детали должны зависеть от абстракций)
*/