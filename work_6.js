/*
		1 Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" Чистого кода.
		Принципы читаемого кода:
			KISS - Always Keep it Simple, Stupid (Будь проще)
				- Ваши методы должны быть небольшими (40 -50 строк)
				- Каждый метод решает одну проблему
				- При модификации кода в будущем не должно быть трудностей
				- Система работает лучше всего, если она не усложняется  без надобности
				- Не устанавливайте целую библиотеку ради одной функции из неё
				- Не делай того что не просят
				- Писать код надо надежно и дубово
			
			YAGNI - You are not gonna need it (Вам это не понадобится)
				- Реализуйте то, что нужно здесь и сейчас, а не в теории, что оно пригодится в будущем
				- Подчищайте ненужный код(Найдите через Git историю при надобности)
				- Программист не должен добавлять новый функционал, о котором его не просят(Благими намереньями без должной проверки вы только добавите багов)
			
			DRY - Dont Repeat Yourself(НЕ повторяйся)
				- Тзбегайте копирования кода
				- выносите общую логику
				- Прежде чем добавить функционал, проверьте в пректе, может, он уже создан
				- Константы

			Бритва Оккама 
				- Не нужно создавать лишние сущности без необходимости в них
				- Всегда начинайте с максимально простого кода, затем увеличивайте сложность по мере необходимости

			BDUF - Big Design Up Front(Сначала большое проектирование)
				- Прежде чем переходить к реализации, убедитесь, что всё продумано
				- разработчик должен сначала завершить проектирование. После этого проект можно реализовать
				- Разделите требования на несколько этапов, определите приоритеты, начинайте с этапа с наивысшим приоритетом
				- Обсудите архитектуру проекта с командой и другими людьми, которые учавствуют в проекте до старта


		Антипаттерны Программирования:
			Антипаттерн - это термин, обозначающий приёмы, которые НЕ нужно применять при решении задачи.

				- Спагетти-код - Это код с практически нулевой структурой. В нём ничего не модулируется. Файлы случайным образом разбросаны по случайным каталогам. Ход программы трудно проследить, он полностью переплетен.

				- Золотой молот (Не используй один архитектурный подход для решения всех задач, не всё хорошо забивать молотком)

				- Лодочный якорь (Не оставляйй неиспользуемый код в базе, потому что он может понадобится позже, эт оприведет к переполнению лишним кодом)

				- Мёртвый код (это код который написали для проверки концепции, а затем запустили в производство. Этот код вреден потому что нельзя определить, нужен ли он для работы программы, или нет)

				- Разрарстание кода (Предпологает наличие в кодовой базе объектов, которые существуют исключительно для вызова других, более важных объектов. Их можно назвать объекты-посредники)

				- Божественный объект (Это объект который делает слишкоом много. Такой антипаттерн еще называют - Швейцарским ножом. его лучше разделить на модули. в ээтом помогает SOLID )
*/ 

/*
		2 Прочитать про способы хранения LocalStorage, SessionStorage и Cookie

		LocalStorage (Локальное хранилище)
			- Хранит данные бессрочно
			- Очищается только при помощи JS или очистки кеша браузера
			- Хранит данные объёмом до 5 МБ
			- Не поддерживается старыми браузерами(IE7 и ниже)
			- Работает по правилу ограничения домена(same origin policy), Сохранённые данные доступны только для одного источника

		SessionStorage (Сессионное хранилище)
			- Хранит данные, пока продолжается текущая сессия. Когда пользователь закроет браузер данные становятся недоступны
			- Использует контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные
			- Объём данных больше чем в Cookie
			- Не поддерживается старыми браузерами(IE7 и ниже)

		Cookie
			- Хранит данные, которые можно передавать на сервер через заголовки
			- Локальные и сессионные хранилища доступны только на клиентской стороне
			- Срок хранения устанавливается при создании Cookie
			- Объём данных не привышает 4 Кбайт
			- Cookie могут быть защищёнными, в этом случае их нельзя получить на стороне клиента. Это важно для аутенфикации при хранении пользовательских токенов
*/ 

/*
		3 HTML / CSS - Базовая структура html документа, БЭМ методология

		Базовая струкиура html документа

		<!DOCTYPE html> - служебная информация для браузера, где описываются стандарты HTML, которые нужно обработать. Документ размечен по стандарту HTML 5
		<html lang="ru"> - указатель языка сайта
		<head> тег заголовка
			<meta charset="UTF-8"> кодировка 
			<title>Базовая струкиура html документа</title> заголовок сайта
		</head>
		<body> тело сайта в нем хранится весь контент сайта
			<h1>Заголовок</h1> заголовок 1 уровня всего их 6
			<p>Текст</p> параграф
		</body>
		</html>

		Методология БЭМ
			БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке. В его основе лежит принцип разделения интерфейса на независимые блоки. Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно использовать существующий код, избегая «Copy-Paste».
*/ 

/*
		4 Почитать про паттерны функционального программирования + посмотреть примеры использования
			Паттерн - это повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.

		Паттерн Модуль
			Модуль - это самостоятельный фрагмент кода, который можно изменять, не затрагивая другой код проекта. Кроме того модули позволяют избегать такого явления как загрязнение областей видимости, так как они создают отдельные области видимости для объявленных в них преременных
				Этот паттерн использует IIFE, замыкания и области видимости функций для имитации этой концепции
				Пример:
				const myModule = (function() {
  
				const privateVariable = 'Hello World';
				
				function privateMethod() {
					console.log(privateVariable);
				}
				return {
					publicMethod: function() {
						privateMethod();
					}
				}
			})();
			myModule.publicMethod();
		
		Паттерн Открытый Модуль
			Представляет собой немного улучшенную версию паттерна Модуль.
			В рассматриваемом паттерне мы назначаем свойствам возвращаемого объекта приватные функции, которые хотим сделать общедоступными.
			Пример:
			const myRevealingModule = (function() {
  
			let privateVar = 'Peter';
			const publicVar  = 'Hello World';
			function privateFunction() {
				console.log('Name: '+ privateVar);
			}
			
			function publicSetName(name) {
				privateVar = name;
			}
			function publicGetName() {
				privateFunction();
			}
			/открываем функции и переменные, назначая их свойствам объекта 
			return {
				setName: publicSetName,
				greeting: publicVar,
				getName: publicGetName
			};
			})();
			myRevealingModule.setName('Mark');
			Выводит Name: Mark
			myRevealingModule.getName();
		Приминение этого паттерна упрощает понимание того, какие функции и переменные модуля общедоступны, что способствует улучшению читабельности кода.


		Паттерн Синглтон
			Представляет собой объект, который может существовать лишь в единственном экземпляре.
			В рамках приминения этого паттерна новый экземпляр некоего класса создаётся в том случае, если он пока не создан.
			Если же экземпляр класса уже существует, то, при попытке обращения к конструктору, возвращается ссылка не существующий объект. Последующий вызовы конструктора всегда будут возвращать тот  же самый объект. 
			Фактически этот паттерн существовал всегда в js и назывался объектным литералом.
			Пример:
			const user = {
				name: 'Peter',
				age: 25,
				job: 'Teacher',
				greet: function() {
					console.log('Hello!');
				}
			}
			Этот паттерн можно реализовать с помощью функции конструктор:
			let instance = null;
			function User(name, age) {
				if(instance) {
					return instance;
				}
				instance = this;
				this.name = name;
				this.age = age;
				
				return instance;
			}
			const user1 = new User('Peter', 25);
			const user2 = new User('Mark', 24);
			выводит true
			console.log(user1 === user2);

		Так же паттерн Синглтон можно реализовать с помощью Паттерна Модуль:
			const singleton = (function() {
				let instance;
				
				function User(name, age) {
					this.name = name;
					this.age = age;
				}
				return {
					getInstance: function(name, age) {
						if(!instance) {
							instance = new User(name, age);
						}
						return instance;
					}
				}
		})();
		const user1 = singleton.getInstance('Peter', 24);
		const user2 = singleton.getInstance('Mark', 26);
		// prints true
		console.log(user1 === user2);


	Паттерн Фабрика
		Паттерн использует для создания объектов так называемые фабричные методы. При этом не требуется указывать классы или функции-кострукторы, которые применяются для создания объектов.
		Этот паттерн используется для создания объектов в случаях, когда не нужно делать общелоступной логику их создания.
		Паттерн Фабрика может быть использован в том случае, если нужно создавать различные объекты в зависимости от специфических условий.
		Пример:
		class Car{
			constructor(options) {
				this.doors = options.doors || 4;
				this.state = options.state || 'brand new';
				this.color = options.color || 'white';
			}
		}
		class Truck {
			constructor(options) {
				this.doors = options.doors || 4;
				this.state = options.state || 'used';
				this.color = options.color || 'black';
			}
		}
		class VehicleFactory {
			createVehicle(options) {
				if(options.vehicleType === 'car') {
					return new Car(options);
				} else if(options.vehicleType === 'truck') {
					return new Truck(options);
					}
			}
		}
		Здесь созданы классы Car и Truck, которые предусматривают использование неких стандартных значений. Они применяются для создания объектов car и truck. Также здесь объявлен класс VehicleFactory, который используется для создания новых объектов на основе анализа свойства vehicleType, передаваемого соответствующему методу возвращаемого им объекта в объекте с параметрами options. Вот как со всем этим работать:
		const factory = new VehicleFactory();
		const car = factory.createVehicle({
			vehicleType: 'car',
			doors: 4,
			color: 'silver',
			state: 'Brand New'
		});
		const truck= factory.createVehicle({
			vehicleType: 'truck',
			doors: 2,
			color: 'white',
			state: 'used'
		});
		Выводит Car {doors: 4, state: "Brand New", color: "silver"}
		console.log(car);
		Выводит Truck {doors: 2, state: "used", color: "white"}
		console.log(truck);
	Здесь создан объект factory класса VehicleFactory. После этого можно создавать объекты классов Car или Truck, вызывая метод factory.createVehicle() и передавая ему объект options со свойством vehicleType, установленным в значение car или truck.

		Паттерн Декоратор
			Используется для расширения функционала объектов без модификации существующих классов или функций-конструкторов.
			Этот паттерн можно использовать для добавления к объектам неких возможностей без модификации кода, который ответственнен за их создание.
			Пример: 
			function Car(name) {
				this.name = name;
				Значение по умолчанию
				this.color = 'White';
			}
			Создание нового объекта, который планируется декорировать
			const tesla= new Car('Tesla Model 3');
			Декорирование объекта - добавление нового функционала
			tesla.setColor = function(color) {
				this.color = color;
			}
			tesla.setPrice = function(price) {
				this.price = price;
			}
			tesla.setColor('black');
			tesla.setPrice(49000);
			Выводит black
			console.log(tesla.color);
*/

/*
		5 Способы позиционирования контента на странице
			Позиционирование позволяет изымать элементы из нормального потока документа и заставить их вести себя по-другому.

		Статическое позиционировани(static)е - это умолчание, которое получает каждый элемент,что означает поставить элемент в его 	нормальное положение в потоке макета документа.

		Относительное позиционирование(relative) - позволяет модифицировать окончательное положение позиционируемого объекта занявшего своё место в макете нормального потока, в том числе заставлять его перекрывать другие элементы на странице. При использовании свойств(top, bottom, left, right)

		Абсолютное позиционирование(absolute) - вырывает элемент из нормального потока документа и будет позиционирован относительно содержащего блока.Если у всех элементов позиционирование static то таким элементом будет исходное окно просмотра.
		Мы можем установить относительно какого элемента будет позиционироваться элемент путем установки позиционирования на один из предков элемента(на один из элементов в который он вложен)

		Так же положением элементов на оси Z управляет Z-Index Который позволяет определять положение на этой оси, положительный -выше, отрицательный - ниже.(по умолчанию у всех z-index = 0)

		Фиксированное позиционирование(fixed) Фиксирует элемент вместе относительно его ближайшего позиционированного предка(исходный содержащий блок если нет иного) 

		Липкое позиционирование(Sticky) - это гибрид относительной и фиксированной позиции, который позволяет позиционируемому элементу вести себя как будто он относительно позиционирован, до тех пор пока он не будет прокручен до определённой пороговой точки, после чего он становится фиксированным 
*/ 

/*
		6 Веса селекторов

		Спецефичность - это алгоритм, багодоря которому браузер определяет, какие именнл стили из всего набора применить к элементу.
		Типы селекторов по убыванию спецефичности:
			- Селекторы по индефикатору
			- Селекторы по классу, по атрибуту и с псевдоклассами
			- Селекторы по тэгу, селекторы с псевдоэлементами

		Комбинаторы +, >, ~ универсальный селектор * и псевдокласс :where() веса не имеют
		Псевдоклассы :is(), :has(), :not() принимают вес наиболее специфичного селектора внутри скобок

		Представим любой селектор в виде трёх нулей: 0.0.0.

			Селекторы по идентификатору увеличивают первую цифру.
			Селекторы по классу, по атрибуту или псевдокласс увеличивают вторую цифру.
			Селектор по тегу или псевдоэлемент увеличивают третью цифру.

		Селектор	                   Вес
		#block section > .list a	  1.1.2
		div#some	                  1.0.1
		#some	                      1.0.0
		* .list a	                  0.1.1
		.class	                    0.1.0
		section h1	                0.0.2
		section	                    0.0.1


	Атрибут style (инлайн стиль) перебивает свойства написанные для этого элемента во внешних css файлах или внутри тега style. Так что формально он самый специфичный и у него самый большой вес. Его иногда добавляют в формулу первой цифрой стоящей перед всеми

	!important  
			Ключевое слово которое нарушает все установленные спецификацией законы и насильно применяет свойства после которого написано.
*/ 