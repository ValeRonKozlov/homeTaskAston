  // 1) Написать ответ - почему массивы в JS являются "неправильными" и совмещают в себе несколько структур данных? Какие?
			
	/*
		Массив в JS являются особой разновидностью обьектов, которые могут хранить наборы данных в виде упорядоченной коллекции. Однако, по сравнению с массивами в других языках программирования, массивы в  JS могут рассматриваться как неправильные из-за того, что они совмещают в себе несколько структур данных: 

			- Упорядоченные списки(каждый элемент имеет свой индекс и доступ к элементам осуществляется по индексу)
			- Наследование от Object (массивы наследуются от объекта и имеют свои методы и свойства, что отличает их от упорядоченных списков, может привести к путанице и непредвиденному поведению)
			- Динамические массивы (они могут менять размер во время выполнения программы, добавляя новые или удаляя существующие элементы массива, это может привести к задержкам потому что JS придется перераспределять память при изменении размера массива)
			- Ассоциативные массивы (в качестве индексов могут использоваться не только числа, но и строки или символы, что позволяет создавать массивы в которых каждому элементу присваивается уникальный ключ)
			- Несоответствие типов элементов (могут содержаться разные типы что может приветси к неожиданным результатам и ошибкам если не учитывать типы)
			- Отсутствие проверки границ (Массив не имеет встроенной проверки границ, что означает, что выход за приделы границ не вызовет ошибки. Это может привести к ошибке индексации или другим ошибкам)
			- Поведение по умолчанию Array.prototype.sort() (Метод sort() по умолчянию для массивов в JS сортирует элементы как строки используя коды Юникода. Это может привести к неожиданным результатам при сортировке числовых или обьектных элементов)

			Из за этих недостатков массивы JS считают неподходящими для использования в критически важных приложениях или приложениях, где требуется надежность и произволительность.
			В качестве альтернатив можно использовать другие структуры данных, такие как Map, Set.

		!! Вопрос: Часто используемые структуры данных?

		1 Arrays - массивы
		2 Stacks - стеки
		3 Queues - очереди
		3 Linked list - связные список
		4 Trees - деревья
		5 Graphs -графы
		6 Tries - префиксное дерево
		7 Hash tables - хэш таблицы
	*/ 

	/* 2) Привязать контекст объекта к функции logger, чтобы при вызове this.item выводило - some value (Привязать через bind, call, apply)
	*/ 
	function logger() {
		console.log(`I output only external context: ${this.item}`);
	}
	
	const obj = { item: "some value" };
	
	logger.bind(obj)();
	logger.call(obj);
	logger.apply(obj);

	// 3.1 Массивы:

// - Создайте массив чисел и найдите его сумму.

	const arr = [1, 2, 3, 4, 5];
	console.log(`Array.reduce: ${arr.reduce((sum, value) => value + sum, 0)}`);
	let result = 0;
	for (let i = 0; i < arr.length; i++) {
		result += arr[i];
	}
	console.log(`For loop: ${result}`);

// - Создайте массив строк и объедините их в одну строку.
	const strArr = ['Hello', 'my', 'name', 'is', 'Valera'];
	console.log(`Reduce: ${strArr.reduceRight((sum, value) => value + sum)}`);
	console.log(`ReduceRight: ${strArr.reduce((sum, value) => value + sum)}`);
	console.log(`Array.join(): ${strArr.join('')}`)
	let newStr = '';
	for (let i = 0; i < strArr.length; i++) {
		newStr += strArr[i];
	}
	console.log(`For loop: ${newStr}`);

// - Найдите максимальный и минимальный элементы в массиве чисел.
	let array = [1, 2, 3, 44, 23, 12, 51, 123, 0, -1];

	console.log(`Min: ${Math.min(...array)}`);
	console.log(`Max: ${Math.max(...array)}`);

	let sortArr = array.sort((a, b) => a - b);

	console.log(`Sort Min: ${sortArr[0]}`);
	console.log(`Sort Max: ${sortArr[sortArr.length - 1]}`);
	


	// 3.2 Stack (стек):

	//  - Реализуйте стек с использованием массива.
	// Stack - это структура данных работающая по принципу LIFO последний пришел первый вышел
		const stack = [];
		// добавляем данные в стек
		stack.push(1);
		stack.push(2);
		stack.push(3);
		// извлекаем данные из стека, method pop() убирает последний элемент из массива
		// stak [1, 2, 3]
		stack.pop(); // 1,2
		stack.pop(); // 1
		stack.pop(); // 

	// 3.3 Queue (очередь):

	//  - Реализуйте очередь с использованием массива.
	//  - Имитируйте работу очереди на примере ожидания на кассе.
	//  Queue (Очередь) - это структура данных работающая по принципу LILO последний пришел последний ушел(как очередь к квссе);
	const queue = [];
	// добавляем данные в очередь
	queue.push(1);
	queue.push(2);
	queue.push(3);
	queue.push(4);
	// извлекаем данные method shift() убирает первый элемент из массива 
	// queue [1, 2, 3, 4]
	queue.shift(); // 2,3,4
	queue.shift(); // 3,4
	queue.shift(); // 4
	queue.shift(); // 

	//  Бонус задание: Реализовать полифил(собственную функцию реализующую встроенную в js) метода bind();
	1.
	const person = {
		name: 'Валерий',
		lastName: 'Козлов'
	}
	const person2 = {
		name: 'Valeron'
	}
	function info() {
		// console.log(`Name: ${this.name}`);
		console.log(this);
	}

	function bind2(fn, context) {
		return function(...args) {
			return fn.apply(context, args)
		}
	}
	const data = [{bar: 'foo'}, {foo: 'bar'}, {foo: 42}, {bar: 24}];
	const data2 = [{bar: 'foo', foo: 'bar', foo: 42, bar: 24}];
	info.bind(person)()
	bind2(info, person)()
	bind2(info, person2)()
	bind2(info, person2)()
	bind2(info, data)()
	bind2(info, data2)()

	
	2.
	const a = function () {
		return this;
	};
	
	function likeBind(func, context) {
		return function(...args) {
			return func.apply(
				context,
				args
			)
		}
	}


	const b = likeBind(a, {foo: 'bar'});
	const c = likeBind(b, null);
	const d = likeBind(c, {bar: 'foo'});

	console.log(c());


/*
			!!! Замыкания это комбинация функции и лексического окрцжения, в котором эта функция была определена. !!! 
			Исключением являются функции созданые через new Function(). Любая функция созданая таким способом ссылается на глобальную область видимости.

			!! Вопрос: 
			Что такое замыкание? И какие функции не являются замыканиями?

			!! Вопроc:
			Когда создаётся замыкание? Замыкание создаётся в момент написания функции

			Лексическое окружение - это специальный обьект, хранящий в себе информацию обо всех локальных переменных и ссылку на внешнее окружение.
			Этот объект скрыт и получить к нему доступ нельзя!!!

			Лекическое окружение создаётся каждый раз когда мы инициялизируем функцию.(когда создаётся функция у неё создаётся скрытое свойство lexical environment)

			LEXICAL ENVIROMENT состоит из:
					Enviroment record - объект, хранящий в себе все локальные переменные(и некоторую другую информацию например this)
					Outer - ссылку на внешнее лексическое окружение

			!! Вопрос:
			Какие переменные считаюся переменными скрытого объекта внутри лексического окружения? 
					(Все локальные переменные т.е при попытке получения доступа к переменной 				сначала идёт обращение к этому объекту достать значение от туда, а затем в случае неудачи идёт обращение по скрытой ссылке outer к объекту переменных внешнего 	окружения. Цикл повторится до тех пор пока переменная не будет найдена или не закончится цепочка внешних окружений)
			

			!! Вопрос:
			Что такое контекст выполнения? Это окружение в котором будет происходить выполнение кода. Он используется для отслеживания хода выполнения кода

			!! Виды контекста выполнения:
				Глобальный контекст выполнения. Это контекст выполнения по умолчанию(глобальный код который не находится в функции находится в глобальном скоупе
				Существует только 1 глобальное окружение Node(global), JS(window));

				Функциональный контекст выполнения создаётся языком в момент вызова функции(каждая функция имеет свой контекст выполнения)

			!! Стек контекстов(call stack) - это список контекстов организованный по принципу LIFO(последний пришёл - первый вышел)
			
			!! Жизненный цикл контекста выполнения:
					Этап создания (вызов функции, this - это указатель на контекст. 
						Создание компонента LexicalEnviroment(лексическое окружение) > определение значения this и осуществляется привязка this(this binding) > Создаётся компонент VariaableEnviroment(окружение переменных))
					Этап запуска (выполняется код функции)
					Этап уничтожения (когда выполнится весь код контекста функции, то он выбрасывается из стека вызова и уничтожается, при этом всегда остаётся global  execution context для доступа ко всему)

				!! Вопрос:
				Сколько способов привязки контекста? (4: New > явная > неявная > по умолчанию)
				Приоритет привязки контекста (New(функции констпуктор) > явная (bind, call, apply) > неявная > по умолчанию)

				!!Привязка по умолчанию:
				function foo() {console.log(this.a)}
				var a = 2;
				foo(); // 2

				!!Неявная привязка:
				function foo() {console.log(this.a)}
				var obj = {
					a: 2;
					foo: foo
				}
				obj.foo(); // 2

				!!Явная привязка
				function foo() {console.log(this.a)}
				var obj = {
					a: 2;
				}
				foo.call(obj) //  2

				!! Привязка new
				function foo(a) {this.a = a}
				var bar = new foo(2);
				console.log(bar.a) // 2

				!! Вопрос:
				Сколько методов(способов) явной привязки контекста? (3: bind > call > apply)
				! главное отличие bind() он создёт функцию с привязанным контекстом, но не вызывает её. 
				bind() - создаёт функцию-обёртку с жёстко созданным контекстом и возвращает её. Контекст передается в качестве первого аргумента. Остальные параметры для передачи в нашу функцию передаются так же как в случае с call() (по отдельности). Однако если во время вызова функции с помощью метода call() данные параметры применяются только на момент вызова, то в случае с bind() аргументы жёстко фиксируются в функци-обёртке. 
				! Один раз привязанный контекст не может быть перепривязан снова

				call() - вызывает функцию с заданным контекстом. Контекст передается в качестве первого аргумента. Остальные аргументы будут переданы непосредственно в саму функцию каждый по отдельности.

				apply() - вызывает функцию с заданным контекстом. Контекст прередается в качестве первого аргумента, вторым аргументом метод принимает массив параметров, с которыми будет вызвана наша функция.

				! Вызов функции через new: (как работает функция конструктор?)

					1 Создается пустой обьект, наследующий прототип из свойства prototype нашей функции
					2 Происходит вызов функции-конструктора с заданными аргументами и this, ссылающийся на обьект из пункта 1
					3 Результатом вызова становится обьект, возвращенный функцией. При этом если возвращаемый обьект не указан явно (при помощи ключевого сова return), то по умолчанию возвращается this. В случае возвращения чего-либо отличного от объекта,(т.е любого примитива) данное значеное игнорируется, а результатом вновь становится this.

				! Контекст вызова в стрелочных функциях:

				У стрелочных функция нет своего this. Даже в случае прямого вызова стрелочной функции в качестве метода у обьекта, this внутри неё всё равно не будет ссылаться на этот обьект.
				Стрелочные функции всегда используют this окружающего контекста.

				!! Вопрос Как потерять контекст?:

				1 Перзаписать в переменную, т.е поменяется ссылка, поменяется контекст 
				2 Использовать стрелочную функцию в ней происходит потеря контекста(тот контекст который мы пытаемся добавить в стрелку юудет виден из вне но не в ней)
				
*/	